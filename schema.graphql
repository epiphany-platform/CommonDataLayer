# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: QueryRoot
    mutation: MutationRoot
    subscription: SubscriptionRoot
}

union ComputationOperator = EqualsComputation | FieldValueComputation | RawValueComputation

"View's filter"
union Filter = ComplexFilter | SimpleFilter

union FilterValue = ComputedFilter | RawValueFilter | SchemaFieldFilter | ViewPathFilter

type CdlObject {
    data: JSON!
    objectId: UUID!
}

type ComplexFilter {
    operands: [Filter!]!
    operator: LogicOperator!
}

type Computation {
    lhs: Computation!
    operator: ComputationOperator!
    rhs: Computation
}

type ComputedFilter {
    computation: Computation!
}

"""

Schema definition stores information about data structure used to push object to database.
Each schema can have only one active definition, under latest version but also contains
history for backward compability.
"""
type Definition {
    "Definition is stored as a JSON value and therefore needs to be valid JSON."
    definition: JSON!
    "Schema is following semantic versioning, querying for \"2.1.0\" will return \"2.1.1\" if exist"
    version: String!
}

type EdgeRelations {
    childObjectIds: [UUID!]!
    parentObjectId: UUID!
    relationId: UUID!
}

type EqualsComputation {
    placeholder: Boolean!
}

type FieldValueComputation {
    baseSchema: UUID
    fieldPath: String!
}

"Schema is the format in which data is to be sent to the Common Data Layer."
type FullSchema {
    """

    Returns schema definition for given version.
    Schema is following semantic versioning, querying for "2.1.0" will return "2.1.1" if exist,
    querying for "=2.1.0" will return "2.1.0" if exist
    """
    definition(versionReq: String!): Definition!
    """

    All definitions connected to this schema.
    Each schema can have only one active definition, under latest version but also contains history for backward compability.
    """
    definitions: [Definition!]!
    "Random UUID assigned on creation"
    id: UUID!
    "Message queue insert_destination to which data is inserted by data-router."
    insertDestination: String!
    "The name is not required to be unique among all schemas (as `id` is the identifier)"
    name: String!
    "Address of the query service responsible for retrieving data from DB"
    queryAddress: String!
    "Whether this schema represents documents or timeseries data."
    type: SchemaType!
    "All views belonging to this schema."
    views: [View!]!
}

"A view under a schema."
type FullView {
    "The ID of the base schema."
    baseSchemaId: UUID!
    "The fields that this view maps with."
    fields: JSON!
    "The ID of the view."
    id: UUID!
    "The address of the materializer this view caches data in."
    materializerAddress: String!
    "Materializer's options encoded in JSON"
    materializerOptions: JSON!
    "The name of the view."
    name: String!
    "The relations that this view has."
    relations: [Relation!]!
}

type MaterializedView {
    "Source view's UUID"
    id: UUID!
    "Materialized objects"
    rows: [RowDefinition!]!
}

type MutationRoot {
    "Add new object-object edges"
    addEdges(relations: [ObjectRelations!]!): Boolean!
    "Add new relation, return generated `relation_id`"
    addRelation(childSchemaId: UUID!, parentSchemaId: UUID!, relationId: UUID): UUID!
    addSchema(new: NewSchema!): FullSchema!
    addSchemaDefinition(newVersion: NewVersion!, schemaId: UUID!): Definition!
    addView(newView: NewView!, schemaId: UUID!, viewId: UUID): View!
    insertBatch(messages: [InputMessage!]!): Boolean!
    insertMessage(message: InputMessage!): Boolean!
    updateSchema(id: UUID!, update: UpdateSchema!): FullSchema!
    updateView(id: UUID!, update: ViewUpdate!): FullView!
}

type QueryRoot {
    "List all relations between schemas stored in database"
    allRelations: [SchemaRelation!]!
    "Return all objects that `parent` object is in `relation_id` relation with"
    edge(parentObjectId: UUID!, relationId: UUID!): [UUID!]!
    "Return all relations that `parent` object is in"
    edges(parentObjectId: UUID!): [EdgeRelations!]!
    "Return a single object from the query router"
    object(objectId: UUID!, schemaId: UUID!): CdlObject!
    "Return a map of objects selected by ID from the query router"
    objects(objectIds: [UUID!]!, schemaId: UUID!): [CdlObject!]!
    "On demand materialized view"
    onDemandView(request: OnDemandViewRequest!): MaterializedView!
    "Return schema `parent` is in `relation_id` relation with"
    relation(parentSchemaId: UUID!, relationId: UUID!): UUID
    "Return single schema for given id"
    schema(id: UUID!): FullSchema!
    "Return a map of all objects (keyed by ID) in a schema from the query router"
    schemaObjects(schemaId: UUID!): [CdlObject!]!
    "Return all relations `parent` is in"
    schemaRelations(parentSchemaId: UUID!): [SchemaRelation!]!
    "Return all schemas in database"
    schemas: [FullSchema!]!
    "Return single view for given id"
    view(id: UUID!): FullView!
}

type RawValueComputation {
    value: JSON!
}

type RawValueFilter {
    value: JSON!
}

"Relation between a view's schemas"
type Relation {
    "Relation ID stored in Edge Registry"
    globalId: UUID!
    "Unique in view definition"
    localId: Int!
    "Subrelations"
    relations: [Relation!]!
    "Looking at relation which direction is important."
    searchFor: SearchFor!
}

type Report {
    "Application which generated the report"
    application: String!
    "Success/Failure"
    description: String!
    "Object id"
    objectId: UUID!
    "Output plugin in command service"
    outputPlugin: String
    "JSON encoded payload"
    payload: JSON!
}

type RowDefinition {
    "Materialized fields"
    fields: JSONObject!
    "Object's UUID"
    objectId: UUID!
}

type SchemaFieldFilter {
    fieldPath: String!
    schemaId: Int!
}

type SchemaRelation {
    childSchemaId: UUID!
    parentSchemaId: UUID!
    relationId: UUID!
}

type SimpleFilter {
    lhs: FilterValue!
    operator: FilterOperator!
    rhs: FilterValue
}

type SubscriptionRoot {
    reports: Report!
}

"A view under a schema."
type View {
    "The fields that this view maps with."
    fields: JSON!
    "Filters used to narrow source objects."
    filters: Filter
    "The ID of the view."
    id: UUID!
    "The address of the materializer this view caches data in."
    materializerAddress: String!
    "Materializer's options encoded in JSON"
    materializerOptions: JSON!
    "The name of the view."
    name: String!
    "The relations that this view has."
    relations: [Relation!]!
}

type ViewPathFilter {
    fieldPath: String!
}

enum FilterOperator {
    EQUALS_OP
}

enum LogicOperator {
    AND
    OR
}

enum SchemaType {
    DOCUMENT_STORAGE
    TIMESERIES
}

enum SearchFor {
    CHILDREN
    PARENTS
}

input InputMessage {
    "Object ID"
    objectId: UUID!
    "JSON-encoded payload"
    payload: JSON!
    "Schema ID"
    schemaId: UUID!
}

"Relation between a view's schemas"
input NewRelation {
    "Relation ID stored in Edge Registry"
    globalId: UUID!
    "Unique in view definition"
    localId: Int!
    "Subrelations"
    relations: [NewRelation!]!
    "Looking at relation which direction is important."
    searchFor: SearchFor!
}

"""

Input object which creates new schema and new definition. Each schema has to
contain at least one definition, which can be later overriden.
"""
input NewSchema {
    "Definition is stored as a JSON value and therefore needs to be valid JSON."
    definition: JSON!
    "Destination to which data is inserted by data-router."
    insertDestination: String!
    "The name is not required to be unique among all schemas (as `id` is the identifier)"
    name: String!
    "Address of the query service responsible for retrieving data from DB"
    queryAddress: String!
    "Whether the schema stores documents or timeseries data."
    type: SchemaType!
}

"Input object which creates new version of existing schema."
input NewVersion {
    "Definition is stored as a JSON value and therefore needs to be valid JSON."
    definition: JSON!
    """

    Schema is following semantic versioning, querying for "2.1.0" will
    return "2.1.1" if it exists. When updating, new version has to be higher
    than highest stored version in DB for given schema.
    """
    version: String!
}

"A new view under a schema."
input NewView {
    "The fields that this view maps with."
    fields: JSON!
    "Filters to the fields"
    filters: JSON
    "The address of the materializer this view caches data in."
    materializerAddress: String!
    "Materializer's options encoded in JSON"
    materializerOptions: JSON!
    "The name of the view."
    name: String!
    "The relations that this view has."
    relations: [NewRelation!]!
}

input ObjectRelations {
    "Relation children"
    childObjectIds: [UUID!]!
    "Relation parent"
    parentObjectId: UUID!
    "Object's schema relations"
    relationId: UUID!
}

input OnDemandViewRequest {
    "Schemas with objects. This collection is treated like a hash-map with `schemaId` as a key, therefore `schemaId` should be unique per request."
    schemas: [Schema!]!
    "View's UUID"
    viewId: UUID!
}

input Schema {
    "Schema's UUID"
    id: UUID!
    "List of the object IDs"
    objectIds: [UUID!]!
}

"""

Input object which updates fields in schema. All fields are optional,
therefore one may update only `topic` or `queryAddress` or all of them.
"""
input UpdateSchema {
    "Destination to which data is inserted by data-router."
    insertDestination: String
    "The name is not required to be unique among all schemas (as `id` is the identifier)"
    name: String
    "Address of the query service responsible for retrieving data from DB"
    queryAddress: String
    "Whether the schema stores documents or timeseries data."
    type: SchemaType
}

"An update to a view. Only the provided properties are updated."
input ViewUpdate {
    "Should filters be updated if not present"
    cleanFilters: Boolean! = false
    "The fields that this view maps with."
    fields: JSON
    "Filters to the fields"
    filters: JSON
    "The address of the materializer this view caches data in."
    materializerAddress: String
    "Materializer's options encoded in JSON"
    materializerOptions: JSON
    "The name of the view."
    name: String
    "The relations that this view has."
    relations: [NewRelation!]
}


"A scalar that can represent any JSON value."
scalar JSON

"A scalar that can represent any JSON Object value."
scalar JSONObject

scalar UUID
