# Front Matter

```
Title           : CDL documentation generation
Author(s)       : ≈Åukasz Biel
Team            : CommonDataLayer
Last updated    : 2021-07-01
Version         : 1.0.0
```

# Glossary

* `CDL` - Common Data Layer
* `QR` - Query Router
* `xtask` - cargo job; similar to how you may define run targets in npm, rake, etc.

# Preface

The necessity of creating this RFC was sparked by amount of manual work needed when documenting API in `QR`.
Some topics I'm exploring here can be stretched to other parts of CDL documentation, and I'm taking my liberty to include
these parts as well. Thus, reader should mind, that result of this document may span across larger group of components than
`QR` alone.

# Current state

`QR` API is documented manually via [OpenApi][OpenApi] spec file. At the moment of writing this rfc it's outdated.  
`Configuration` is documented manually via [toml][configuration-docs] files compliant with [rust config crate][config-rs].  
`gRPC` configuration is hand-written and [tonic][tonic-rs] generates rust files with code needed for client and server implementation; proto files are located in [rpc crate][cdl-rpc-rs].  
`CDL Input Message` format is documented by hand in [docs][cdl-input-message]. At the moment of writing this rfc it's outdated.  
`Notification Message` format is not documented to my knowing.  
`graphQL` provides documentation via its endpoint and it's built into library we use. It may be wort considering to provide static graphQL spec in repository.

# Problem to solve

Maintaining documentation for formats used in communication within or with CDL is cumbersome.
We need to research options of automating the process and validating its results.

# Possible solutions

## Generate rust code from specification files:

There are options for generating rust code from proto (already in place) and OpenAPI.
For generating structures needed for our internal and external communication, via Kafka and RabbitMQ, we could use [schemafy crate][schemafy-rs].
It most likely needs to be done via `xtask`, similar to how we are generating things using [tonic][tonic-rs].
As for OpenAPI, it would require us to switch away from using [warp][warp-rs] in favour of [hyper][hyper-rs]. It would generate new crate in our repo, 
that `QR` would use as a base.
For graphQL api - we would need to provide a `xtask` which pulls spec from running api instance.
TOML configuration is a bit more problematic. There are no known crates that can easily generate rust structs out from Toml config, and structs
are usually reused. What I mean is that generating code would introduce duplication. It's not necessarily bad, but introduces some confusion.
We probably would need to produce an in-house solution for that problem.

In general - it requires some significant work from team to switch fully to configs generating rust code.

[OpenApi]: https://swagger.io/specification/
[configuration-docs]: ../configuration/index.md
[cdl-input-message]: ../architecture/data_router.md
[cdl-rpc-rs]: ../../crates/rpc/proto
[tonic-rs]: https://github.com/hyperium/tonic
[config-rs]: https://github.com/mehcode/config-rs
[schemafy-rs]: https://docs.rs/schemafy/0.5.2/schemafy/
[warp-rs]: https://github.com/seanmonstar/warp
[hyper-rs]: https://github.com/hyperium/hyper
