# Edge registry - Resolving relation trees

## Motivation
Our current process on resolving relation trees is far from ideal - e.g. it allows querying from only one side of the relation, doesn't support complex filtering(required for materialization).
This document's purpose is to pass on the way behavior can be handled. Struct names and similar concepts are treated as implementation detail which may be changed during implementation.

## Proposed changes

### TreeQuery request

```rust 
type Identifier = u8; // id from TreeQuery->Relation, 0 for base_relation

struct TreeQuery{
    base_relation: Uuid,
    filters: Option<Filter>,
    relations: [Relation],
}

enum Filter {
    SimpleFilter,
    ComplexFilter,
}

struct ComplexFilter {
    operator: LogicOperator,
    operands: [Filter],
}

// To be extended later
enum LogicOperator {
    And,
    Or,
}

enum SimpleFilter {
    InParentObjIds {
        relation: Identifier,
        ids: Vec<Uuid> 
    },
    InChildObjIds{
        relation: Identifier,
        ids: Vec<Uuid>
    }
}

struct Relation {
    relation_id: UUID,
    identifier: NonZeroU8, // Unique in request
    side: RelationSide,
    relations: [Relation],
}

enum RelationSide {
    Parents,
    Children,
}
```

New request type is similar to some parts of view definitions stored in schema registry(requirements about filtering and relation querying are almost the same for both services). Noticeable difference is `SimpleFilter` enum which allows only for filtering based on object ids(on both side of relation).


### TreeQuery response

```rust
struct TreeQueryResponse {
    resp: [Uuid] // number of rows * (2 + TreeQuery.relations.len())
}
```
UUID order - base_relation_parent_id, base_relation_child_id, (relation_x_child_id)*
relation_x - relation with identifier value x

Why single array(Vec) of UUIDs, not Vec<Vec<UUID>> or something similar to distinguish rows - nested vectors means a lot of small allocations which are terrible for cpu cache. Using rust iterators allows us to handle both solutions the same way, so this optimization shouldn't be problematic from code side.

Completely different from pervious response:
- flat form - OB was not using tree form, it first step was flattening old response format - no need for this extra processig
- simple struct - much better nested block depth, possibility of single memory allocation(better for caching)
- no relation information(only edges) - in old format same information about relations was sent multiple times, more info in [Getting relation information](#getting_relation)

It might seem that this format introduces duplication(some ids will be sent multiple times), however that shouldn't be a problem. This is the ideal case for usage of lossless algorithms on protocol level(if needed). Similar solutions(table results) are widely used with rdbms and I don't recall any performance issues about sending the data.

### Processing TreeQuery request

- Resolving relation tree should be handled by using `inner join` strategy. This may be configurable in the future.
- Filtering based on object_ids should be performed.
- It might be a good idea to let sql engine to do almost all the work for us and just generate sql query and collect the results. Efficient joining and filtering data is one of the main goals of rdbms and it doesn't require as much network chatter as doing it on our own. This is just a proposal - implementator is free to choose which way this should be handled.


### <a name="getting_relation"></a>Getting relation information

```patch
service EdgeRegistry {
...
+  rpc GetRelation(RelationQuery) returns (RelationList);
-  rpc GetRelation(RelationQuery) returns (RelationResponse);
...
-  rpc ListRelations(Empty) returns (RelationList);
}
...
message RelationQuery {
  required string relation_id = 1;
-  required string parent_schema_id = 2;
}

```

Parent schema id is not required for fetching relation information. I'm not sure why this field was added there as required. Removing it and allowing to query multiple relations in one request will serve requirements given by object_id. It will also make `ListRelations` obsolete as the same thing should bo possible to achieve by sending empty `RelationQuery`.

Extracting fetching relation metadata from TreeQuery shouldn't cause any performance problems as those two requests can(should) be ran in parallel by OB. It will also allow implementation of [#573](https://github.com/epiphany-platform/CommonDataLayer/issues/573) if we decide to implement it.


